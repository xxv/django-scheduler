"""Support for serializing dateutil.rrules to iCalendar RRULE strings

This package licensed under the The Apache Software License, Version 1.1
Copyright (c) 2004-2006 Jeffrey Harris.  All rights reserved.

See LICENSE.APACHE.txt for more details.

This was lovingly carved out of the vobject.icalendar module and updated for
our modern times.
"""

import dateutil.rrule
import dateutil.tz
from io import StringIO
import datetime



#------------------------------- Constants -------------------------------------
DATENAMES = ("rdate", "exdate")
RULENAMES = ("exrule", "rrule")
DATESANDRULES = ("exrule", "rrule", "rdate", "exdate")
PRODID = u"-//PYVOBJECT//NONSGML Version 1//EN"

WEEKDAYS = "MO", "TU", "WE", "TH", "FR", "SA", "SU"
FREQUENCIES = ('YEARLY', 'MONTHLY', 'WEEKLY', 'DAILY', 'HOURLY', 'MINUTELY',
               'SECONDLY')

zeroDelta = datetime.timedelta(0)
twoHours  = datetime.timedelta(hours=2)

#---------------------------- TZID registry ------------------------------------
def rruleset_str(dtstart, rruleset):
    isDate = datetime.date == type(dtstart)
    if isDate:
        dtstart = datetime.datetime(dtstart.year,dtstart.month, dtstart.day)
        untilSerialize = dateToString
    else:
        # make sure to convert time zones to UTC
        untilSerialize = lambda x: dateTimeToString(x, True)

    for name in DATESANDRULES:
        setlist = getattr(rruleset, '_' + name)
        if name in DATENAMES:
            setlist = list(setlist) # make a copy of the list
            if name == 'rdate' and dtstart in setlist:
                setlist.remove(dtstart)
            if isDate:
                setlist = [dt.date() for dt in setlist]
            if len(setlist) > 0:
                pass
        elif name in RULENAMES:
            for rule in setlist:
                rrule_str(dtstart, rule)

def rrule_str(dtstart, rule):
    isDate = datetime.date == type(dtstart)
    if isDate:
        dtstart = datetime.datetime(dtstart.year,dtstart.month, dtstart.day)
        untilSerialize = dateToString
    else:
        # make sure to convert time zones to UTC
        untilSerialize = lambda x: dateTimeToString(x, True)

    buf = StringIO()
    buf.write('FREQ=')
    buf.write(FREQUENCIES[rule._freq])

    values = {}

    if rule._interval != 1:
        values['INTERVAL'] = [str(rule._interval)]
    if rule._wkst != 0: # wkst defaults to Monday
        values['WKST'] = [WEEKDAYS[rule._wkst]]
    if rule._bysetpos is not None:
        values['BYSETPOS'] = [str(i) for i in rule._bysetpos]

    if rule._count is not None:
        values['COUNT'] = [str(rule._count)]
    elif rule._until is not None:
        values['UNTIL'] = [untilSerialize(rule._until)]

    days = []
    if (rule._byweekday is not None and (
                  dateutil.rrule.WEEKLY != rule._freq or
                   len(rule._byweekday) != 1 or
                rule._dtstart.weekday() != rule._byweekday[0])):
        # ignore byweekday if freq is WEEKLY and day correlates
        # with dtstart because it was automatically set by
        # dateutil
        days.extend(WEEKDAYS[n] for n in rule._byweekday)

    if rule._bynweekday is not None:
        days.extend(str(n) + WEEKDAYS[day] for day, n in rule._bynweekday)

    if len(days) > 0:
        values['BYDAY'] = days

    if rule._bymonthday is not None and len(rule._bymonthday) > 0:
        if not (rule._freq <= dateutil.rrule.MONTHLY and
                len(rule._bymonthday) == 1 and
                rule._bymonthday[0] == rule._dtstart.day):
            # ignore bymonthday if it's generated by dateutil
            values['BYMONTHDAY'] = [str(n) for n in rule._bymonthday]

    if rule._bymonth is not None and len(rule._bymonth) > 0:
        if (rule._byweekday is not None or
            len(rule._bynweekday or ()) > 0 or
            not (rule._freq == dateutil.rrule.YEARLY and
                 len(rule._bymonth) == 1 and
                 rule._bymonth[0] == rule._dtstart.month)):
            # ignore bymonth if it's generated by dateutil
            values['BYMONTH'] = [str(n) for n in rule._bymonth]

    if rule._byyearday is not None:
        values['BYYEARDAY'] = [str(n) for n in rule._byyearday]
    if rule._byweekno is not None:
        values['BYWEEKNO'] = [str(n) for n in rule._byweekno]

    # byhour, byminute, bysecond are always ignored for now


    for key, paramvals in values.items():
        buf.write(';')
        buf.write(key)
        buf.write('=')
        buf.write(','.join(paramvals))

    v=buf.getvalue()
    buf.close()
    return v

#---------------------------- TZID registry ------------------------------------
__tzidMap={}

def registerTzid(tzid, tzinfo):
    """Register a tzid -> tzinfo mapping."""
    __tzidMap[tzid]=tzinfo

def getTzid(tzid):
    """Return the tzid if it exists, or None."""
    return __tzidMap.get(tzid, None)

utc = dateutil.tz.tzutc()
registerTzid("UTC", utc)


def dateTimeToString(dateTime, convertToUTC=False):
    """Ignore tzinfo unless convertToUTC.  Output string."""
    if dateTime.tzinfo and convertToUTC:
        dateTime = dateTime.astimezone(utc)
    if tzinfo_eq(dateTime.tzinfo, utc): utcString = "Z"
    else: utcString = ""

    year  = numToDigits( dateTime.year,  4 )
    month = numToDigits( dateTime.month, 2 )
    day   = numToDigits( dateTime.day,   2 )
    hour  = numToDigits( dateTime.hour,  2 )
    mins  = numToDigits( dateTime.minute,  2 )
    secs  = numToDigits( dateTime.second,  2 )

    return year + month + day + "T" + hour + mins + secs + utcString


def dateToString(date):
    year  = numToDigits( date.year,  4 )
    month = numToDigits( date.month, 2 )
    day   = numToDigits( date.day,   2 )
    return year + month + day

def numToDigits(num, places):
    """Helper, for converting numbers to textual digits."""
    s = str(num)
    if len(s) < places:
        return ("0" * (places - len(s))) + s
    elif len(s) > places:
        return s[len(s)-places: ]
    else:
        return s

def getTransition(transitionTo, year, tzinfo):
    """Return the datetime of the transition to/from DST, or None."""

    def firstTransition(iterDates, test):
        """
        Return the last date not matching test, or None if all tests matched.
        """
        success = None
        for dt in iterDates:
            if not test(dt):
                success = dt
            else:
                if success is not None:
                    return success
        return success # may be None

def tzinfo_eq(tzinfo1, tzinfo2, startYear = 2000, endYear=2020):
    """Compare offsets and DST transitions from startYear to endYear."""
    if tzinfo1 == tzinfo2:
        return True
    elif tzinfo1 is None or tzinfo2 is None:
        return False
    
    def dt_test(dt):
        if dt is None:
            return True
        return tzinfo1.utcoffset(dt) == tzinfo2.utcoffset(dt)

    if not dt_test(datetime.datetime(startYear, 1, 1)):
        return False
    for year in xrange(startYear, endYear):
        for transitionTo in 'daylight', 'standard':
            t1=getTransition(transitionTo, year, tzinfo1)
            t2=getTransition(transitionTo, year, tzinfo2)
            if t1 != t2 or not dt_test(t1):
                return False
    return True

